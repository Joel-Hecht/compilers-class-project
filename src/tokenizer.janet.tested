#!/usr/local/bin/janet
# parse source args/string into tokens
# implemented as a generator

(use ./utils)

# automated inline snapshot tests
# explicit assertion tests can be found in test/
(use judge)

(defn charToKeyword [c] 
	(def vals @[])
	(put vals 0 :sym)
	(put vals 1 
		(case c
			"(" :lp
			")" :rp
			"{" :lb
			"}" :rb
			":" :colon
			"!" :not
			"@" :at
			"^" :caret
			"&" :amp
			"." :dot
			"," :comma
			"\n" :nl
			(do
				(put vals 0 :op)
				(case c

					"+" :+
					"-" :-
					"*" :*
					"/" :/
					"=" :=
					(do
						(put vals 0 :num)
						(if (peg/match charIsNumber c)
							c
							(do
								(if (peg/match charIsLetter c)
									(do
										(put vals 0 :id)
										c
									)
									(do
										(put vals 0 :INVALID)
										:INVALID
									)
								)
							)
						)						
					)
				)
			)
		)
	)
	(if (= (get vals 0) :sym)
		{:type (get vals 1) }
		{:type (get vals 0) :tok (get vals 1)}
	)
)

(defn typesNeededFor [t]
	(if (= t :num)
		[:num]
		(if (= t :id)
			[:num :id]
			[]
		)
	)
)

(defn insertMultiCharToken [tok ]
	(def newtok
		{ :type
			(case (tok :tok)
				"if" :iff
				"ifonly" :ifonly
			  "while" :w
				"return" :ret
				"print" :print
				"this" :th
				(tok :type)
			)	
			:tok (tok :tok) #messy but I'm just gonna leave in the token value even if it is identical to the type

		}
	)
	(yield newtok)
)

(defn advanceToken [remaining needsTypes prev ] 
	(if (= remaining "")
		(do
			(when prev
				(yield prev)
			)
			(yield {:type :eof})
		)
		(do
			#advnace spaces	
			(def thischar (string/slice remaining 0 1) )
			(def newremaining (string/slice remaining 1) )
			(if (= thischar " ")
				(do 
					(when (not (empty? needsTypes ))
						(insertMultiCharToken prev )
					) #if ongoing token
					(advanceToken newremaining [] false ) 
				) #if whitespace
				(do
					(def tok (charToKeyword thischar ))
					(if (value-in? (tok :type) needsTypes)
						(advanceToken newremaining needsTypes {:type (prev :type) :tok (string (prev :tok) (tok :tok)) }  )
						(do
							(defn getNextRecursion [] 
								(do
									(if (or (= (tok :type) :id) (= (tok :type) :num))
										(advanceToken newremaining (typesNeededFor (tok :type)) tok )
										(do
											(yield tok )
											(advanceToken newremaining [] false )
										)
									)# if num or id
								)
							) #defn
							(when (not (empty? needsTypes))
								(insertMultiCharToken prev )
							) #if has needed types
							(getNextRecursion)
						)
					)	#if in needstypes
				)
			) #if space
		)
	)	
)

(defn getNextToken [f]
	(:getNext f)
)

(defn peekNextToken [f]
	(:peek f)
)

(defn make-tokenizer [str]
	(make-fiber-with-cache (fiber/new (fn [] (advanceToken str [] false ))))

)

(defn make-tokenizer-from-args [args]	
	(def str (joinArgs args))
	(make-tokenizer str)
)

(defn get-all-tokens [t]
	(def list @[])
	(forever
		(array/push list (getNextToken t))
		(when (= ((array/peek list) :type) :eof) 
			(break)	
		)
	)
	list
)

(defn make-get-all [str]
	(get-all-tokens (make-tokenizer str))	
)

(defn print-all-tokens [t]
	(pp (get-all-tokens t))
)

(defn main [& args] 
	#remove arg, since that is the name of the program
	(def t (make-tokenizer-from-args (rest args)))
	(print-all-tokens t)
)

# Using judge:
# test that tokenizer is identifying tokens correctly
(test (make-get-all "") @[{:type :eof}])
(test (make-get-all " ") @[{:type :eof}])
(test (make-get-all "(\n") @[{:type :lp} {:type :nl} {:type :eof}])
(test (make-get-all "a+b")
  @[{:tok "a" :type :id}
    {:tok :+ :type :op}
    {:tok "b" :type :id}
    {:type :eof}])
(test (make-get-all "arg+123-")
  @[{:tok "arg" :type :id}
    {:tok :+ :type :op}
    {:tok "123" :type :num}
    {:tok :- :type :op}
    {:type :eof}])
(test (make-get-all "123") @[{:tok "123" :type :num} {:type :eof}])
(test (make-get-all "args ") @[{:tok "args" :type :id} {:type :eof}])
(test (make-get-all "testu") @[{:tok "testu" :type :id} {:type :eof}])

